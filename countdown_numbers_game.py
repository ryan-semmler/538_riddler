import random


class N:
    # Represents a number card
    # If the number was generated by combining two other cards,
    # the card will hold the combined value, but display as the original values.
    def __init__(self, val, display=None):
        self.val = val
        if display:
            self.display = display
        else:
            self.display = str(self.val)

    def __str__(self):
        return self.display

    __repr__ = __str__

    def __eq__(self, other):
        if isinstance(other, int):
            return self.val == other
        return self.val == other.val


def can_make_number(cards, number):
    """
    Takes a list of cards (as N objects), and tries to reach the target number by combining cards arithmetically.
    If possible, return the series of operations needed to reach the target. Otherwise return False.
    """
    if any(isinstance(card, int) for card in cards):
        cards = [N(card) for card in cards]
    for card in cards:
        if card == number:
            return str(card)
    for card in cards:
        other_cards = list(cards)
        other_cards.remove(card)
        result = can_make_number(other_cards, number - card.val)
        if result is not False:
            return result + f"+{card}"
        if number % card.val == 0:
            result = can_make_number(other_cards, number // card.val)
            if result is not False:
                return result + f"*{card}"
        for c in [item for item in other_cards if item.val < card.val]:
            other_other_cards = list(other_cards)
            other_other_cards.remove(c)
            ops = list('*+-')
            if card.val % c.val == 0:
                ops.insert(0, '//')
            for op in ops:
                new_value = eval(f"{card.val}{op}{c.val}")
                result = can_make_number(other_other_cards + [N(new_value, f"({card}{op}{c})")], number)
                if result:
                    return result
    return False


def game(large):
    """
    Simulates one game by generating a list of cards and a target number and looking for a valid solution.
    There will always be exactly six cards.
    'large' is the number of large values in the six-card deck. The rest are all small numbers.
    """
    six_cards = random.sample([25, 50, 75, 100], k=large)
    six_cards.extend(random.sample(list(range(1, 11)) * 2, k=6 - large))
    six_cards.sort(reverse=True)
    target = random.randint(100, 999)
    return target, six_cards, can_make_number(six_cards, target)
